## Guideline16
Visitorパターン: 動的多様性を選択した際に、処理の追加がOCP違反になることへの対応策
Visitorパターンのバリエーションポイントは、処理の追加

## 処理の追加
- 図形クラスに加えて図形の処理(描画や回転など)を実行する新規クラスを追加して、図形と処理を分離する

## Visitor(Cycle Visitor: 古典的なVisitor)
長所:
- 処理追加が苦手な動的多様性実装に対して、容易に処理を追加できること

短所:
- 図形のクローズドセットが前提であり、それが崩れるとVisitorの基底クラスの変更が強いられること
- 処理内容は型による違いをほとんど受けないため、型ごとに近しい実装を繰り返すこと
- 実装上位にaccept()を持つ必要があること
- 型の追加には必ずaccept()を実装する必要があること(実装を忘れても警告が出ないため型の追加が困難になる)
- ダブルディスパッチになり実行時コストが高いこと
- 具象図形クラスの具象化など多くの小さなメモリ割り当ては実行時コストが高く、長時間動作するプログラムならば外部フラグメンテーションを起こす可能性がある
- 具象図形クラスがキャッシュされずらい
- Visitorは全体を把握し保守する難易度が高い

※ 短所の原因
- 図形具象クラス、図形基底クラス、Visitor基底クラスの循環する依存関係によるもの
- 図形具象クラスは、図形規定クラスに依存している
- 図形基底クラスは、accept()を持つためVisitor基底クラスに依存している
- Visitor基底クラスは、各図形具象クラスごとにvisit()と持つため、各図形具象クラスに依存している

## 用語
- バリエーションポイント: 変動点、亜種分岐点
- ダブルディスパッチ: 仮装関数コールを2回行う必要があること(Vtableを２回解決する必要がありコストがかかり遅くなる)
- メモリフラグメンテーション: 内部フラグメンテーション+外部フラグメンテーション
- 内部フラグメンテーション: メモリ取得した際に、割り当てられるメモリに無駄が発生してしまうこと(1KBを保存するために4KB割り当てられる)
- 外部フラグメンテーション: メモリに十分な空き容量が存在しているにもかかわらず、連続した空きメモリが存在せずメモリを取得できないこと
- キャッシュされずらい: 動的コンテンツの場合、古いデータが残らないようにキャッシュしない
